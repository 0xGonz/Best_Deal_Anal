Here‚Äôs where every ‚Äú why-isn‚Äôt-this-number-updating ‚Äù bug keeps sneaking in, and the fastest way to make the weights, capital-called cards, and the dynamic table all read straight from live data instead of frozen snapshots.

1 ‚Äì Your numbers are still assembled in three different places
SQL ‚Äì the view/trigger we just added now produces a correct capital_called figure.

Node service layer ‚Äì AllocationService.getAllocationsWithMeta() loops over those rows and recomputes totals again (reduce).

React components ‚Äì the dashboard cards run their own sumBy() on the React-Query payload, and the position-weight column does yet another division.

Because only layer ‚ë† actually talks to Postgres, layers ‚ë° and ‚ë¢ are often working on stale cache or an outdated copy of the formula.

Fix ‚Äì move all aggregation into a single database view and let every layer just render the columns it receives.

sql
Copy
Edit
create or replace view vw_fund_overview as
select  f.id               as fund_id,
        f.name             as fund_name,
        sum(a.amount)      as committed,
        sum(a.capital_called) as called,
        sum(a.amount) - sum(a.capital_called) as uncalled,
        round( 100.0 * sum(a.amount) / nullif(f.total_commitments,0) , 2)
                             as weight_pct
from    funds f
join    vw_fund_allocations a on a.fund_id = f.id
group   by f.id;
Now the ‚ÄúCalled vs Un-called‚Äù card, the weight column, and any pie-chart can all read the same three numbers: committed, called, uncalled.

2 ‚Äì React Query cache isn‚Äôt invalidated after a capital-call
You post a new call, the DB is right, but the cards/table still show the old snapshot because React-Query hasn‚Äôt been told to refetch.

ts
Copy
Edit
const createCall = useMutation(postCapitalCall, {
  onSuccess: () => {
    queryClient.invalidateQueries(['fund-overview']);   // the view above
    queryClient.invalidateQueries(['allocations']);
  }
});
No invalidation ‚Üí no UI refresh.
Add the two lines once and every card updates the moment a call is saved.

3 ‚Äì The ‚Äúweight‚Äù column uses a prop that never changes
Inside the table component you have something like:

ts
Copy
Edit
const totalFundCommitments = props.initialTotals.committed;  // <- snapshot
const weight = amount / totalFundCommitments;
Switch to reactive data:

ts
Copy
Edit
const { committed } = useFundOverview(fundId);               // live number
const weight = amount / committed;
and memo-wrap the expensive part so the row doesn‚Äôt re-render on every keystroke:

ts
Copy
Edit
const weightPct = useMemo(() => amount / committed, [amount, committed]);
4 ‚Äì Server still sending two different shapes
GET /api/funds/:id/overview returns { committed, called },
while GET /api/allocations nests capitalCalled inside each row.
Front-end mapping logic gets messy and someone inevitably forgets to update one path.

Expose one canonical DTO ‚Äì either:

ts
Copy
Edit
type FundOverview = {
  fundId: number;
  committed: number;
  called: number;
  uncalled: number;
  weightPct: number;
  allocations: AllocationRow[];
};
or break it into two endpoints but keep the same field names. Every renaming (‚ÄúcapitalCalled‚Äù vs ‚Äúcalled‚Äù) is a future bug.

5 ‚Äì Realtime feel without websockets
If you don‚Äôt want to wire sockets yet, give your critical queries a short staleTime:

ts
Copy
Edit
useQuery(['fund-overview', fundId], fetchFn, { staleTime: 0 })   // refetch on window focus
React-Query will re-hit the endpoint any time the user tabs away and back, which
usually feels ‚Äúlive‚Äù enough for finance dashboards without extra infra.

üî¥ Quick punch-list to ship tonight
Create vw_fund_overview (SQL block above).

Change FundController.getOverview() to select * from vw_fund_overview where fund_id = :id.

Replace every in-component total with the numbers that endpoint returns.

Add invalidateQueries to createCapitalCall and any edit/delete mutation.

Set staleTime: 0 on the overview and allocation queries.

Do those five and:

the cards will flick from ‚ÄúCalled 1 M / Un-called 1.5 M‚Äù to the new totals as soon as you save a capital call,

the weight column will always divide by the most current fund commitment,

no more hand-maintained loops in React or Node‚Äîthe database is the single source of truth.

Let me know which part you hit first and I can walk you through the exact code diff if anything‚Äôs unclear.









Ask ChatGPT
