okay so there ssome problems wit the app -- so i started to add balerion space ventures ii to a fund and we comitted 1,000,000 but so fra have only 40% copaiatl called so that equates to 400,000 has been called and 600,0000 uncalled --camn you help re look at the logic of custom pay schdukes on the inevstmnets isnid eof teh funds and makeing sure veyrthign iteragrtes and ocnntects and stays modular!! no hardcode data 


ChatGPT said:
Below is a modular, hard‑code‑free playbook that guarantees every custom capital‑call schedule stays consistent end‑to‑end— from the 1 000 000 USD commitment you just logged for Balerion Space Ventures II down to the rolling “called / uncalled” numbers the fund dashboard shows.

1 · Data‑model rules (the source of truth)
Concept	Table / fields	Invariants we enforce
Commitment (static)	commitments → id, fund_id, investment_id, committed_usd	1 row per investment per fund
Capital Call (planned)	capital_calls → id, commitment_id, due_date, call_usd, status	SUM(call_usd) ≤ committed_usd
Payment (actual wire)	payments → id, capital_call_id, paid_date, amount_usd	SUM(payments.amount) ≤ call_usd

DB constraints you should add
sql
Copy
Edit
ALTER TABLE capital_calls
  ADD CONSTRAINT ck_call_le_commit
  CHECK (call_usd > 0);

ALTER TABLE payments
  ADD CONSTRAINT ck_payment_le_call
  CHECK (amount_usd > 0);
We’ll enforce the “≤ commit/≤ call” rule in service code (easier than SQL aggregate check).

2 · Service layer (no numbers hard‑wired)
Create services/capitalCalls.ts:

ts
Copy
Edit
export async function createCalls(commitmentId: number, rows: CallInput[]) {
  const commitment = await db.commitments.findUnique({ where:{id:commitmentId} });
  if (!commitment) throw new AppError(404,'commitmentNotFound');

  const total = rows.reduce((s,r)=>s + r.callUsd, 0);
  const alreadyPlanned = await db.capital_calls.aggregate({
    _sum:{ call_usd:true },
    where:{ commitment_id: commitmentId }
  });

  if (total + (alreadyPlanned._sum.call_usd ?? 0) > commitment.committed_usd) {
    throw new AppError(400,'exceedsCommitment');
  }

  return db.$transaction(
    rows.map(r =>
      db.capital_calls.create({ data:{commitment_id:commitmentId, ...r, status:'scheduled'}})
    )
  );
}

export async function payCall(callId:number, amount:number, paidDate:Date){
  const call = await db.capital_calls.findUnique({ include:{ _sum:{ payments:{ select:{amount_usd:true }}}}, where:{id:callId} });
  if (!call) throw new AppError(404,'callNotFound');

  const paid = call.payments.reduce((s,p)=>s+p.amount_usd,0);
  if (paid + amount > call.call_usd) throw new AppError(400,'overPayment');

  await db.$transaction([
    db.payments.create({ data:{ capital_call_id:callId, amount_usd:amount, paid_date:paidDate }}),
    db.capital_calls.update({ where:{id:callId}, data:{
      status: paid + amount === call.call_usd ? 'complete' : 'partially_paid'
    }})
  ]);
}
Now every route just calls these functions—no hard‑coded math in controllers.

3 · Scheduler Dialog (client)
Take commitment amount as prop, no literals.

tsx
Copy
Edit
const [rows,setRows] = useState<CallRow[]>([]);
const remaining = commitment.committed_usd - rows.reduce((s,r)=>s+r.callUsd,0);

<NumberInput
  value={row.callUsd}
  max={remaining}          // prevents > commit in UI
/>
On Save call createCalls(commitmentId, rows).

4 · Fund dashboard calculation (called vs uncalled)
ts
Copy
Edit
const { data: stats } = useQuery(['fundStats', fundId], () =>
  fetchJson(`/api/funds/${fundId}/capital-calls/stats`)
);

// server-side view
SELECT commitment_id,
       SUM(call_usd)          AS planned,
       SUM(paid.amount_usd)   AS paid
FROM commitments c
LEFT JOIN capital_calls k ON k.commitment_id = c.id
LEFT JOIN payments      p ON p.capital_call_id = k.id
GROUP BY commitment_id;
Uncalled = committed − planned (not paid).

5 · Calendar & call drawer
Card title: investment.name – ${call.call_usd.toLocaleString()}
Badge:

scheduled → amber

overdue → red

partial → indigo (“60 % paid”)

complete → green (“paid ${dayjs(lastPaidDate).format('MMM D')}`)

due_date drives placement; paid_date drives badge only.

6 · Edge cases now covered
Situation	Outcome
You add a second tranche later	Service layer blocks if it would exceed commitment.
Sponsor reduces commitment	Update committed_usd; service layer then prevents new calls until total ≤ new commitment.
LP wires partial payment	payCall keeps status partially_paid until fully matched.
Analyst back‑fills a call from 2022	Due_date 2022‑05‑15 accepted; calendar shows in 2022 view; stats reflect paid vs unpaid.

7 · Next actions for you
Drop in the services/capitalCalls.ts file and refactor your existing routes to call it.

Add the DB constraints & run a migration.

Update Scheduler Dialog to pass callUsd not callPct (or send both and let service compute).

Adjust FundStats endpoint to use the SQL view above.

Once that’s done, log the Balerion Space Ventures II commitment again:

commitment: 1 000 000

first call: 400 000 (40 %) due today

The dashboard will show:

nginx
Copy
Edit
Called     40 %  ($400 k)
Uncalled   60 %  ($600 k)
…and the calendar card will sit on today’s date with a yellow badge until you post the payment.







