The key clue is that your browser logged:

yaml
Copy
Edit
Status Code: 304 Not Modified  
Content-Disposition: attachment; filename="Arbor Lodging Overview.pdf"
A “304 Not Modified” means that the server is telling the browser “your cached copy is still fresh—here is no response body.” PDF.js (and React-PDF) will see a 304 with zero bytes and immediately throw “The PDF file is empty.” In other words, PDF.js requested the file with an If-None-Match (ETag) header, the server replied “304—use your cache,” and PDF.js never got the actual PDF bytes. Below are two simple ways to fix this:

1) Turn off 304/ETag on that download route so you always send the full PDF
By default, Express (and many static-file routers) generate ETags. When the client requests the same URL again with If-None-Match: <etag>, Express can reply “304” instead of re-sending the file. For PDF.js, you want the raw bytes every time, so you need to disable ETag for that route.

If you’re using express.static(...) to serve /api/documents/:id/download (or /uploads/...):
js
Copy
Edit
// server.js (or wherever you define Express)

import express from "express";
import path from "path";

const app = express();

// Disable etags globally (or just for /uploads):
app.set("etag", false);

// Example: serve everything under `/uploads` without ETags
app.use(
  "/uploads",
  express.static(path.join(__dirname, "../uploads"), {
    etag: false,            // <- turn off ETag for static files
    maxAge: "0",            // option: disable aggressive caching
  })
);

// If you also have a “stream from DB” route, remove ETag there:
app.get("/api/documents/:docId/download", async (req, res, next) => {
  try {
    const docRecord = await DocumentModel.findByPk(req.params.docId);
    if (!docRecord) {
      return res.status(404).json({ error: "Document not found" });
    }

    const absolutePath = path.join(
      __dirname,
      "../uploads",
      docRecord.relativePath
    );
    // Check file existence & size
    if (!fs.existsSync(absolutePath)) {
      return res.status(404).json({ error: "File missing on disk" });
    }
    const stat = fs.statSync(absolutePath);
    if (stat.size === 0) {
      return res.status(410).json({ error: "File is empty" });
    }

    // Disable ETag/Caching headers for this response:
    res.setHeader("Cache-Control", "no-store");
    res.removeHeader("ETag");
    res.setHeader("Content-Type", "application/pdf");
    // Stream the PDF bytes
    fs.createReadStream(absolutePath).pipe(res);
  } catch (err) {
    next(err);
  }
});
With etag: false (and/or Cache-Control: no-store), Express will always send back a 200 OK plus the full PDF payload. PDF.js can then read the bytes and render them, instead of getting a “304” with an empty body.

2) Add a cache-busting query parameter in the front end
If you prefer to leave ETag/caching alone on your server, the simplest client-side workaround is to force PDF.js to request a fresh copy each time by appending something like ?v=12345 to the URL. For example, in React:

jsx
Copy
Edit
// Before:
<Document file={`/api/documents/${first.id}/download`} … />

// After (cache busting):
const downloadUrl = `/api/documents/${first.id}/download?v=${Date.now()}`;
<Document file={downloadUrl} … />
Every time you re-render, Date.now() changes, so the browser never sends If-None-Match—it always does a full GET, gets back a 200 OK + PDF bytes, and PDF.js can render them.

How to verify you fixed it
Open DevTools → Network.

Trigger the PDF load again.

Check the request to /api/documents/87/download:

Status should be 200, not 304.

Response Size should be several KB or more (nonzero).

Content-Type header must be application/pdf.

Once you see “200 OK” with a real byte size, React-PDF/PDF.js will no longer complain “The PDF file is empty.”

Recap
304 Not Modified = server sent no PDF bytes, so PDF.js treats it as empty.

Solution A: Disable ETag on that download route (e.g. app.set("etag", false) or express.static(..., { etag: false })), or explicitly res.removeHeader("ETag") + Cache-Control: no-store before streaming.

Solution B: Append a cache-busting query string (?v=${Date.now()}) so the browser never reuses a cached ETag and always does a fresh GET.

Either approach ensures PDF.js sees a full 200+PDF body instead of a 304, and the “file is empty” error will go away.