It turns out the “0‐byte PDF” problem is not a PDF.js bug at all but rather our download‐endpoint never actually sends the bytes back—so the browser is literally receiving an empty file. There are two flavors of document‐storage in your repo (“fixed” and “persistent”), and in both cases the “download” function ends up deleting or returning only metadata instead of returning the raw Buffer/stream. Below is a walkthrough of exactly why the file is empty and how to fix it.

1. Why the browser sees “0 bytes”
In your console logs we see:

css
Copy
Edit
❌ PDF load error: Ane { message: "The PDF file is empty, i.e. its size is zero bytes.", … }
That error is coming straight from PDF.js, which has fetched a zero‐length response from /api/documents/87/download. In other words, every time the front‐end asks for “/api/documents/:id/download,” the server is replying with an empty body (length 0). PDF.js then complains that the PDF has no bytes.

When we search through your server/routes folder, there are two download paths:

“Fixed” version (in routes/documents‐fixed.ts)

“Persistent” version (in routes/documents‐persistent.ts)

In both cases, the code that reads the file is there, but by the time the handler returns, it never actually passes the Buffer/stream down to Express’s res. Instead, it either deletes the record or returns a success‐object. That is why the client sees 0 bytes.

1.1. “Fixed” storage path (file‐system)
Open server/routes/documents‐fixed.ts. You will find something like this around the download route:

ts
Copy
Edit
router.get('/:id/download', async (req, res, next) => {
  const documentId = Number(req.params.id);
  try {
    // This is where you ask your documentStorage to “download”…
    const result = await documentStorage.downloadDocument(documentId);
    if (!result) {
      return res.status(404).send();
    }

    // Instead of returning the file contents, “downloadDocument” deletes the row and returns a success object:
    return res.json(result);
  } catch (error) {
    next(error);
  }
});
But inside documentStorage.downloadDocument(…) (which is in server/services/unified-document-storage.ts), you’ll see code like:

ts
Copy
Edit
async downloadDocument(documentId: number) {
  try {
    const document = await this.getDocument(documentId);
    if (!document) {
      return null;
    }

    const fullPath = path.join(process.cwd(), document.filePath);
    const fileBuffer = await fs.readFile(fullPath);

    // …then they delete the DB record, log success, and return only metadata:
    await db
      .delete(documents)
      .where(eq(documents.id, documentId));

    return { success: true, deletedDocument: document };
  } catch (error) {
    console.error(`❌ Error deleting document ${documentId}:`, error);
    throw error;
  }
}
Notice:

They read fileBuffer = await fs.readFile(fullPath)…

Then they delete the row from the database…

Finally they return { success: true, … }, never calling res.send(fileBuffer) or piping that fileBuffer down.

Because the handler above only does res.json(result), the client never gets fileBuffer. It just gets a JSON object with { success: true, deletedDocument: { … } }, which is obviously not a PDF at all—so PDF.js sees zero bytes.

1.2. “Persistent” storage path (BLOB in PostgreSQL)
Open server/routes/documents-persistent.ts. The download route is analogous. It calls into something like:

ts
Copy
Edit
router.get('/:id/download', async (req, res, next) => {
  const documentId = Number(req.params.id);
  try {
    const result = await DocumentBlobStorage.retrieveDocument(documentId);
    if (!result) {
      return res.status(404).send();
    }
    // Again, instead of sending back the Buffer, you delete the row and return metadata:
    return res.json(result);
  } catch (err) {
    next(err);
  }
});
Inside server/services/document-blob-storage.ts, the retrieveDocument function looks roughly like:

ts
Copy
Edit
static async retrieveDocument(documentId: number) {
  const storedDoc = await db.query(/*…select file_data BLOB…*/);
  if (!storedDoc) {
    return null;
  }
  const fileBuffer = storedDoc.file_data; // <— a Buffer from Postgres

  // then they delete from the documents table
  await db.delete(/* … */).where(/*…*/);

  // finally, they return only a “success” object—not the Buffer
  return { success: true, deletedDocument: storedDoc.metadata };
}
Again, by the time Express’s route sees it, it only has { success: true }, not the raw PDF bytes.

2. How to fix it
You need to:

Read the file from disk (or from the BLOB)

Send those bytes as an HTTP response (with the correct headers)

Only after sending the bytes (if you really must delete the row) do you delete the row or file on disk.

Below are code snippets that show exactly what needs to change.

2.1. “Fixed” storage: return the raw Buffer and then delete
In server/routes/documents-fixed.ts, find the GET '/:id/download' handler and replace it with something like this:

ts
Copy
Edit
router.get('/:id/download', async (req, res, next) => {
  const documentId = Number(req.params.id);
  try {
    // 1) Fetch the metadata (including filePath) but do NOT delete it yet:
    const document = await documentStorage.getDocument(documentId);
    if (!document) {
      return res.status(404).send('Not found');
    }

    // 2) Read the file off disk:
    const fullPath = path.join(process.cwd(), document.filePath);
    const fileBuffer = await fs.readFile(fullPath);

    // 3) Send the Buffer as a PDF response:
    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader(
      'Content-Disposition',
      `attachment; filename="${document.fileName || 'download.pdf'}"`
    );
    res.send(fileBuffer);

    // 4) Only AFTER sending, delete the row from the database (or file from disk).
    //    If you absolutely need to clean up, kick off a fire‐and‐forget:
    setImmediate(async () => {
      try {
        await db.delete(documents).where(eq(documents.id, documentId));
        // Optionally remove the file from disk too:
        // await fs.unlink(fullPath);
      } catch (err) {
        console.error('Error deleting document after download:', err);
      }
    });
  } catch (error) {
    next(error);
  }
});
What changed:

We call documentStorage.getDocument(documentId) (instead of downloadDocument(...)) so that we get filePath without deleting the record immediately.

We read await fs.readFile(fullPath) into a Buffer.

We set Content-Type: application/pdf and Content-Disposition: attachment; filename=….

We do res.send(fileBuffer) so the raw bytes go straight to the browser.

Only after sending we schedule the deletion of the DB row (and/or file on disk).

That way, PDF.js in the browser receives the complete PDF bytes instead of an empty JSON object.

2.2. “Persistent” storage: return the raw BLOB and then delete
In server/routes/documents-persistent.ts, you may currently have:

ts
Copy
Edit
router.get('/:id/download', async (req, res, next) => {
  const documentId = Number(req.params.id);
  try {
    const result = await DocumentBlobStorage.retrieveDocument(documentId);
    if (!result) {
      return res.status(404).send();
    }
    return res.json(result);
  } catch (err) {
    next(err);
  }
});
Change it to something like:

ts
Copy
Edit
router.get('/:id/download', async (req, res, next) => {
  const documentId = Number(req.params.id);
  try {
    // 1) Fetch the row (with BLOB) but do not delete it yet:
    const storedRow = await DocumentBlobStorage.getDocumentRow(documentId);
    if (!storedRow) {
      return res.status(404).send('Not found');
    }

    // 2) The raw PDF bytes are in storedRow.file_data:
    const fileBuffer: Buffer = storedRow.file_data;

    // 3) Send the bytes down:
    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader(
      'Content-Disposition',
      `attachment; filename="${storedRow.file_name || 'download.pdf'}"`
    );
    res.send(fileBuffer);

    // 4) After sending, delete the row from the database:
    setImmediate(async () => {
      try {
        await db.delete(documents).where(eq(documents.id, documentId));
      } catch (err) {
        console.error('Error deleting persistent document after download:', err);
      }
    });
  } catch (err) {
    next(err);
  }
});
Here’s what changed:

We call DocumentBlobStorage.getDocumentRow(documentId) (or whatever method returns exactly { file_data: Buffer, file_name: string, … }) instead of a method that deletes immediately.

We stream the raw Buffer to res.send(fileBuffer) with Content-Type: application/pdf.

Then we delete the database row on a setImmediate(…) so that the HTTP response is not blocked.

3. How to verify your fix
Restart your server.

Upload a PDF under the “Fixed” or “Persistent” flow as before.

Open your browser’s Network tab and click the “Download” link. You should now see:

A 200 OK response to /api/documents/87/download

Under “Response” you should see ~50KB or 200KB (whatever your PDF is) instead of 0 B.

PDF.js will then render the document normally.

Check the database to see that the row has been deleted only after the download. If you open the “Documents” table in PGAdmin (or print SELECT * FROM documents WHERE id = 87;), you should see it vanish after the download completes.

4. Summary
Root cause: Both “fixed” and “persistent” download endpoints were returning a JSON object (after deleting) instead of raw PDF bytes. PDF.js got an empty or wrong response → “0 bytes”.

Fix: Change the route so that it (a) reads the file (from disk or BLOB) into a Buffer, (b) sends that Buffer with res.send(buffer) (and proper Content-Type/Content-Disposition), and only then (c) does any deletion/cleanup.

Once you do that, the PDF.js error “The PDF file is empty” will go away.

With these edits, you’ll see the PDF stream over the network as nonzero bytes, and PDF.js will be able to render it in the browser.








