Below is an “everything-has-to-balance” playbook that shows—step by step—how a deal should flow from Committed → Part-Paid → Fully Funded and how those numbers roll up into “Called vs Uncalled Capital” at the fund level.

If you wire it up exactly like this, the UI can’t go out of sync again.

1 Canonical data model
Table	Key columns	What lives here	Never store
fund_allocations	id, fund_id, deal_id	committed_amount (fixed)	called_amount, funded_amount (derive them)
capital_calls	id, allocation_id, seq_no	amount, due_date	–
payments	id, capital_call_id	amount, value_date	–

Generated columns
sql
Copy
Edit
ALTER TABLE fund_allocations
ADD COLUMN called_amount NUMERIC(18,2) GENERATED ALWAYS AS
  (COALESCE(
     (SELECT SUM(amount) FROM capital_calls c WHERE c.allocation_id = id),0)
  ) STORED,
ADD COLUMN funded_amount NUMERIC(18,2) GENERATED ALWAYS AS
  (COALESCE(
     (SELECT SUM(p.amount)
        FROM capital_calls cc
        JOIN payments p ON p.capital_call_id = cc.id
       WHERE cc.allocation_id = id),0)
  ) STORED;
With these generated fields:

ini
Copy
Edit
uncalled_capital = committed_amount – called_amount
unfunded_called  = called_amount    – funded_amount
No service ever updates totals by hand—Postgres keeps them right.

2 State machine (one-way traffic)
pgsql
Copy
Edit
          ┌──────────────┐
          │  committed   │
          └──────┬───────┘
                 │ "create call"
                 ▼
      ┌────────────────────────┐
      │ partially_called       │  (0 < called < committed)
      └──────┬────────┬────────┘
             │        │ "call remainder"
             │        ▼
             │  ┌──────────────┐
             │  │   called     │  (called = committed)
             │  └──────┬───────┘
             │         │ "payments start"
             ▼         ▼
┌────────────────┐ ┌───────────────────────┐
│partially_funded│ │ funded (terminal)     │
└────────────────┘ └───────────────────────┘
Enforce in code once (e.g., AllocationFSM.transition()).
Every write route triggers an FSM event; invalid transitions → 409 Conflict.

3 API contract (verbs, not nouns)
Verb	Route	Body	FSM event
POST	/allocations	{fundId, dealId, committed}	ALLOCATE
POST	/allocations/{id}/calls	{amount, dueDate}	CREATE_CALL
POST	/capital-calls/{id}/payments	{amount, txRef}	PAYMENT_RECEIVED

No POST /payments without capitalCallId.
Front-end must pass the open call’s id.

4 Integrity rails in SQL (catch bugs before they hit JS)
sql
Copy
Edit
-- Cannot insert a payment without a call
ALTER TABLE payments
  ADD CONSTRAINT fk_call NOT NULL
  REFERENCES capital_calls(id) ON DELETE RESTRICT;

-- Cannot allocate same deal twice to one fund
ALTER TABLE fund_allocations
  ADD CONSTRAINT unique_fund_deal UNIQUE (fund_id, deal_id);
5 Called vs Uncalled capital roll-up
Fund-level view:

sql
Copy
Edit
CREATE VIEW fund_capital AS
SELECT
  f.id,
  SUM(a.committed_amount) AS total_committed,
  SUM(a.called_amount)    AS total_called,
  SUM(a.funded_amount)    AS total_funded,
  SUM(a.committed_amount - a.called_amount) AS uncalled_capital,
  SUM(a.called_amount - a.funded_amount)    AS outstanding_calls
FROM funds f
LEFT JOIN fund_allocations a ON a.fund_id = f.id
GROUP BY f.id;
The investor dashboard simply selects from fund_capital; no math in React.

6 Smoke-test script (CI must run on every PR)
pgsql
Copy
Edit
1. POST /allocations  commit=1,000,000
   → state = committed, uncalled=1,000,000

2. POST /allocations/{id}/calls  amount=400,000
   → state = partially_called
   → called = 400,000  uncalled = 600,000

3. POST /capital-calls/{call}/payments  amount=400,000
   → state = partially_funded
   → outstanding_calls = 0

4. POST second call 600,000
   → state = called
   → called = committed

5. Pay 600,000
   → state = funded (terminal)
   → outstanding_calls = 0, uncalled = 0
Fail any step → pipeline is broken.

7 Why this scales
Generated columns + views → totals stay correct if you import 50 000 historic payments tomorrow.

FSM caps state explosions—new services can’t invent illegal transitions.

DB constraints surface bugs instantly; you don’t discover them in a quarterly LP letter.

API verbs decouple front-end and batch import tools; they all hit the same contract.

Lock these pieces in, rerun the smoke test, and the “committed vs partial vs funded” numbers will always reconcile—no matter how many deals, funds, or payments flow through the system.