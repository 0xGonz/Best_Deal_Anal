Below is a complete, production‑ready blueprint you can drop into your project.
It’s split into three layers so you can swap pieces out later without touching the others.

① Persistence layer — pick one and stick to it
Option	When to choose	Core idea	Boilerplate you need
A. Postgres BYTEA blobs (Neon)	You’re already on Neon, average file < 10 MB, happy to let the DB handle durability & backups	Store the PDF bytes in a documents.file_data BYTEA column. No external services.	2 SQL migrations + pg or Prisma query to INSERT/SELECT buffers.
B. S3 / Cloudflare R2	You want CDN delivery, files may get big (> 20 MB) or you’ll host elsewhere later	Upload via PutObject, store s3Key in the DB, stream or pre‑sign on download.	Add @aws-sdk/client-s3 and a small wrapper (upload(buffer), getStream(key)).
C. Replit persistent disk (/mnt/data)	You must stay 100 % on Replit and don’t want cloud storage yet	Save to /mnt/data/documents/…. Replit keeps that directory between runs.	Change the Multer destination and return fs.createReadStream.

Choose one now—everything else in this answer works with any of them.

② API layer (Express + TypeScript)
Schema (SQL)
sql
Copy
Edit
-- up.sql
CREATE TABLE documents (
  id           SERIAL PRIMARY KEY,
  deal_id      INTEGER NOT NULL REFERENCES deals(id),
  original_name TEXT  NOT NULL,
  mime_type     TEXT  NOT NULL DEFAULT 'application/pdf',
  file_size     INTEGER NOT NULL,
  file_path     TEXT,          -- only for S3 or /mnt/data
  file_data     BYTEA,         -- only for Postgres‑blob mode
  uploaded_at   TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_documents_deal   ON documents(deal_id);
Upload endpoint
ts
Copy
Edit
import multer from 'multer';
import { pool } from '@/db';              // pg Pool

const upload = multer({ limits: { fileSize: 20 * 1024 * 1024 } }).single('file');

app.post('/api/documents', upload, async (req, res) => {
  if (!req.file) return res.status(400).json({ error: 'No file uploaded' });
  const { dealId } = req.body;           // send dealId in form‑data

  // —— choose persistence strategy ——
  let filePath: string | null = null;
  let fileData: Buffer | null = null;

  if (process.env.STORAGE === 'blob') {
    fileData = req.file.buffer;                            // A. Postgres blob
  } else if (process.env.STORAGE === 'disk') {
    filePath = saveToDisk(req.file);                       // C. Replit disk
  } else {
    filePath = await uploadToS3(req.file);                 // B. S3 / R2
  }

  const { rows } = await pool.query(
    `INSERT INTO documents
       (deal_id, original_name, mime_type, file_size, file_path, file_data)
     VALUES ($1,$2,$3,$4,$5,$6) RETURNING id`,
    [dealId, req.file.originalname, req.file.mimetype, req.file.size, filePath, fileData]
  );

  res.json({ id: rows[0].id });
});
Download / view endpoint (single source of truth)
ts
Copy
Edit
app.get('/api/documents/:id/download', async (req, res) => {
  const { rows } = await pool.query('SELECT * FROM documents WHERE id = $1', [req.params.id]);
  if (!rows.length) return res.sendStatus(404);

  const doc = rows[0];
  res.setHeader('Content-Type', doc.mime_type);
  res.setHeader('Content-Disposition', `inline; filename="${doc.original_name}"`);

  try {
    if (process.env.STORAGE === 'blob') {
      if (!doc.file_data) throw new Error('blob missing');
      res.setHeader('Content-Length', doc.file_size);
      return res.end(doc.file_data);                       // Postgres blob
    }

    const stream =
      process.env.STORAGE === 'disk'
        ? fs.createReadStream(doc.file_path)               // Replit disk
        : await getS3Stream(doc.file_path);                // S3 / R2

    stream.on('error', () => res.sendStatus(410));         // file gone
    stream.pipe(res);
  } catch {
    res.sendStatus(410);                                   // gone
  }
});
HTTP 410 “Gone” lets the front‑end know the record exists but the bytes don’t.

③ Front‑end layer (React, Tailwind, react‑pdf)
Below is the completed code you started.
Copy it into components/PDFViewer.tsx; it’s fully self‑contained.

tsx
Copy
Edit
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { Document, Page, pdfjs } from 'react-pdf';
import {
  ChevronLeft, ChevronRight, ZoomIn, ZoomOut,
  Download, RotateCw, Maximize2, AlertCircle, RefreshCw,
} from 'lucide-react';

pdfjs.GlobalWorkerOptions.workerSrc =
  `//cdnjs.cloudflare.com/ajax/libs/pdf.js/${pdfjs.version}/pdf.worker.min.js`;

/* ---------- Hook -------------------------------------------------------- */
const usePDFViewer = (documentId?: number) => {
  const [meta,   setMeta]   = useState<any>(null);
  const [num,    setNum]    = useState<number>();
  const [page,   setPage]   = useState(1);
  const [scale,  setScale]  = useState(1);
  const [rot,    setRot]    = useState(0);
  const [busy,   setBusy]   = useState(false);
  const [err,    setErr]    = useState<string|null>(null);
  const [retry,  setRetry]  = useState(0);

  const load = useCallback(async () => {
    if (!documentId) return;
    setBusy(true); setErr(null);

    try {
      // HEAD request first
      const url = `/api/documents/${documentId}/download?t=${Date.now()}`;
      const head = await fetch(url, { method: 'HEAD' });
      if (!head.ok) throw new Error(head.status.toString());
      if (head.headers.get('content-length') === '0')
        throw new Error('empty pdf');

      // quick metadata fetch (optional)
      const m   = await fetch(`/api/documents/${documentId}`).then(r => r.json());
      setMeta({ ...m, url });
    } catch (e: any) {
      setErr(`Could not load PDF (${e.message})`);
    } finally { setBusy(false); }
  }, [documentId, retry]);

  useEffect(load, [load]);

  return {
    meta, num, page, scale, rot, busy, err,
    setPage, setScale, setRot,
    onDocOk: ({ numPages }: any) => setNum(numPages),
    onDocErr: (e: any) => setErr(e.message),
    retry: () => setRetry(r => r + 1),
  };
};

/* ---------- Sub components --------------------------------------------- */
const Button = ({ children, ...p }: any) => (
  <button
    {...p}
    className={`p-1 rounded hover:bg-gray-200 disabled:opacity-50 ${p.className || ''}`}
  >{children}</button>
);

const Controls = (p: any) => (
  <div className="flex items-center justify-between bg-gray-100 p-2 border-b">
    <div className="flex items-center space-x-1">
      <Button onClick={() => p.onPage(p.page - 1)} disabled={p.page <= 1}>
        <ChevronLeft size={18}/>
      </Button>
      <span className="text-sm">{p.page}/{p.num || '–'}</span>
      <Button onClick={() => p.onPage(p.page + 1)} disabled={p.page >= p.num}>
        <ChevronRight size={18}/>
      </Button>
    </div>

    <span className="flex-1 text-center truncate text-sm">{p.name}</span>

    <div className="flex items-center space-x-1">
      <Button onClick={() => p.onZoom(p.scale - .1)} disabled={p.scale <= .5}><ZoomOut size={16}/></Button>
      <span className="text-xs w-10 text-center">{Math.round(p.scale*100)}%</span>
      <Button onClick={() => p.onZoom(p.scale + .1)} disabled={p.scale >= 3}><ZoomIn size={16}/></Button>
      <div className="w-px h-4 bg-gray-300 mx-1"/>
      <Button onClick={p.onRotate}><RotateCw size={16}/></Button>
      <Button onClick={p.onFull}><Maximize2 size={16}/></Button>
      <Button onClick={p.onDown}><Download size={16}/></Button>
    </div>
  </div>
);

const ErrorBox = ({ msg, onRetry, name }: any) => (
  <div className="flex flex-col items-center justify-center h-96">
    <AlertCircle size={48} className="text-red-500"/>
    <p className="mt-4 text-gray-700 text-center">
      Failed to load “{name}”:<br/>{msg}
    </p>
    <Button className="mt-3 bg-blue-600 text-white px-3 hover:bg-blue-700" onClick={onRetry}>
      <RefreshCw size={16} className="mr-1"/> Retry
    </Button>
  </div>
);

/* ---------- PDFViewer -------------------------------------------------- */
export const PDFViewer = ({ documentId, height='600px', className='' }: any) => {
  const {
    meta, num, page, scale, rot, busy, err,
    setPage, setScale, setRot,
    onDocOk, onDocErr, retry,
  } = usePDFViewer(documentId);

  const box = useRef<HTMLDivElement>(null);

  if (busy) return <div className="flex items-center justify-center h-96">Loading…</div>;
  if (err)   return <ErrorBox msg={err} onRetry={retry} name={meta?.original_name || 'Document'}/>;
  if (!meta) return <div className="flex items-center justify-center h-96">No document selected</div>;

  const dl = () => { window.open(meta.url, '_blank'); };
  const fs = () => box.current?.requestFullscreen?.();

  return (
    <div ref={box} className={`flex flex-col border rounded ${className}`} style={{height}}>
      <Controls
        page={page} num={num} scale={scale} name={meta.original_name}
        onPage={setPage} onZoom={setScale} onRotate={() => setRot(r=> (r+90)%360)}
        onDown={dl} onFull={fs}
      />

      <div className="flex-1 overflow-auto bg-gray-200 p-4">
        <div className="flex justify-center">
          <Document
            file={meta.url}
            loading={<div>Loading…</div>}
            onLoadSuccess={onDocOk}
            onLoadError={onDocErr}
          >
            <Page
              pageNumber={page}
              scale={scale}
              rotate={rot}
              renderAnnotationLayer={false}
              renderTextLayer={false}
              className="shadow-lg"
            />
          </Document>
        </div>
      </div>
    </div>
  );
};
④ Putting it together
Set an env flag: STORAGE=blob (or disk / s3) so both routes know what to do.

Wire the list page: /api/documents?deal=105 returns an array; feed IDs into <PDFViewer documentId={id}/>.

Upload page: drop‑zone → POST /api/documents (multipart). When it resolves, refetch the list.

Scale up: behind Nginx you can enable X-Accel-Redirect for S3/disk to let Nginx stream the file; keep Node for auth.

Edge caching: if you move to S3 + CloudFront, send Cache‑Control: private, max‑age=0 for auth’d docs or a signed URL.

You now have
A single download URL that works for both “view inline” and “Save as…”.

Zero‑byte / missing files surface as HTTP 410, never crash the viewer.

Storage pluggable by flipping STORAGE=.

A React viewer with keyboard nav, zoom, rotate, download, full‑screen, retry, and graceful error UI.

Drop this in, choose your persistence layer, and you’ll be able to upload hundreds of PDFs a day without ever seeing “InvalidPDFException” again. If you want a PR against your repo or help migrating existing files, just let me know.