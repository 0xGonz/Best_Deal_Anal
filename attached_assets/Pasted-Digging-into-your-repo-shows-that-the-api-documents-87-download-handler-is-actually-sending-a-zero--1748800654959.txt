Digging into your repo shows that the /api/documents/87/download handler is actually sending a zero‚Äêbyte response (hence the ETag "W/"0-‚Ä¶") rather than streaming the real PDF off disk. In other words, PDF.js is getting back a 304 (or a 200 with a 0-byte body) and rightly complains ‚ÄúThe PDF file is empty.‚Äù

Below is a summary of what‚Äôs happening and exactly where to patch:

1. Why the server is returning a zero-byte body
In server/routes/documents-database.ts (around line 150), you have something like:

ts
Copy
Edit
// ‚Ä¶inside router.get('/:id/download', ‚Ä¶)‚Ä¶
const document = await databaseDocumentStorage.getDocument(documentId);
if (!document) return res.status(404).json({ error: 'Not found' });

// 1) If document.fileData is truthy, you convert that base64 into a Buffer:
if (document.fileData) {
  const fileBuffer = Buffer.from(document.fileData, 'base64');
  // ‚Ä¶ set headers, then:
  return res.send(fileBuffer);
}

// 2) Otherwise you fall back to filesystem:
//    (document.filePath should point to wherever the file lives on disk)
if (document.filePath) {
  const fullPath = path.resolve(document.filePath);
  if (!fs.existsSync(fullPath)) {
    return res.status(410).json({ error: 'Legacy file not found' });
  }
  // ‚Ä¶set Content-Type, Content-Disposition‚Ä¶
  return fs.createReadStream(fullPath).pipe(res);
}

// 3) If neither branch is hit, you send 410:
return res.status(410).json({ error: 'Document not available' });
Two things can cause a zero-byte response here:

The database row‚Äôs fileData is non-null but actually empty (‚Äú‚Äù‚Äú‚Äù).
In that case, document.fileData is truthy (a string), so you do Buffer.from('', 'base64') ‚Üí a Buffer of length 0 ‚Üí you send that. Express then computes an ETag of "0-‚Ä¶" and replies ‚Äú200 + zero bytes.‚Äù On the next request the browser sends If-None-Match: "0-‚Ä¶", and Express answers ‚Äú304 Not Modified‚Äù (no body). PDF.js sees ‚Äú304 / 0 bytes‚Äù and throws ‚ÄúInvalidPDFException: The PDF file is empty.‚Äù

document.fileData is null or undefined, but your code never actually hits the filesystem branch because document.filePath is invalid or empty. In that case you jump past the FS section and hit the final 410 (which PDF.js also treats as ‚Äúempty PDF‚Äù), but‚Äîwith ETags‚Äîyou might see a 304 if you previously saw a ‚Äú200 + no bytes.‚Äù

Either way, PDF.js never sees real PDF bytes.

2. How to confirm which branch ran
Open DevTools ‚Üí Network and click the /api/documents/87/download request.

If you see Status 304 Not Modified with an ETag W/"0-‚Ä¶" and a Content-Length: 0, it means the ‚Äúdatabase fileData‚Äù branch sent a zero-byte buffer.

If you instead see Status 200 + Content-Type: application/pdf but size = 0 bytes, that is also the DB branch sending an empty Buffer.

Look in your server‚Äôs console (Repl.it logs). The download route logs a message when it hits the FS fallback:

javascript
Copy
Edit
console.log(`üìÇ Serving legacy document ${documentId} from filesystem: ${document.filePath}`);
If you do not see that ‚ÄúüìÇ Serving legacy‚Ä¶‚Äù message, it means the document.fileData branch ran first. You can add a console.log above each branch to be sure.

Check the database for record 87. In psql (or whatever), run:

sql
Copy
Edit
SELECT fileData, filePath, fileSize FROM documents WHERE id = 87;
If fileData is a zero‚Äêlength string (''), the code will mistakenly treat it as ‚Äútruthy‚Äù and send a 0-byte Buffer.

If fileData is actually NULL, but filePath is wrong (empty or pointing to a non-existent file), you never hit the fs.createReadStream and end up returning 410 (or maybe a 200 with no bytes).

3. How to fix it
A) Make sure the code only treats a nonempty fileData as ‚Äúsend buffer‚Äù
Change the if (document.fileData) check to verify length > 0. For example, in document-database.ts:

ts
Copy
Edit
// Old (problematic) check:
if (document.fileData) {
  // fileBuffer = Buffer.from(document.fileData, 'base64')
  // ‚Ä¶send buffer‚Ä¶
}

// Replace with:
if (document.fileData && document.fileData.length > 0) {
  const fileBuffer = Buffer.from(document.fileData, 'base64');
  // You can log fileBuffer.length here to confirm it‚Äôs > 0
  res.setHeader('Content-Type', document.fileType);
  res.setHeader('Content-Disposition', `inline; filename="${encodeURIComponent(document.fileName)}"`);
  res.setHeader('Content-Length', fileBuffer.length.toString());
  return res.send(fileBuffer);
}
This way, if fileData exists but is the empty string, you skip right to the filesystem fallback.

B) Verify document.filePath is correct and points to an actual disk file
Check where your files live. In your repo, you have actual PDFs under

swift
Copy
Edit
/storage/documents/deal-101/17486192521-Confidential_Offering_Memorandum_Lake_Vue_Apartments.pdf
but we need to confirm that record 87 was uploaded to, say, /storage/documents/deal-108/Arbor Lodging Overview.pdf.

In your DB, filePath is a text column. If, for instance, filePath was stored as just "deal-108/Arbor Lodging Overview.pdf", then path.resolve(document.filePath) resolves to something like /home/runner/workspace/deal-108/Arbor Lodging Overview.pdf, not /home/runner/workspace/storage/documents/deal-108/‚Ä¶. That would cause fs.existsSync(fullPath) to return false, skipping the FS stream entirely.

To fix that, you must store filePath as the full relative path under storage/documents. In unified-document-storage.ts, you should be building filePath like:

ts
Copy
Edit
const targetDir = path.join(this.STORAGE_BASE_PATH, `deal-${dealId}`);
const savedPath = path.join(targetDir, originalFileName);
// then save `savedPath` into the DB
That way, document.filePath === 'storage/documents/deal-108/Arbor Lodging Overview.pdf'. Then:

ts
Copy
Edit
const fullPath = path.resolve(document.filePath);
// ‚Üí "/home/runner/‚Ä¶/storage/documents/deal-108/Arbor Lodging Overview.pdf"
Make sure the file actually exists at that location on disk.

After you correct filePath, do a one-off test in the Repl.it shell:

bash
Copy
Edit
ls -l storage/documents/deal-108/Arbor\ Lodging\ Overview.pdf
# and also in Node REPL:
node -e "console.log(require('fs').existsSync('storage/documents/deal-108/Arbor Lodging Overview.pdf'))"
If these return true and you see the correct bytes on disk, you know the filesystem fallback can run.

C) Disable caching/ETag altogether for this route (so you always get a 200 + full PDF)
Right now, even after you send a 0-byte buffer once, the browser caches that ETag ("W/\"0-‚Ä¶\"") and responds with If-None-Match ‚Üí your server returns 304. To completely disable that:

At the top of your Express app (in e.g. server/vite.ts or wherever you set up the server), add:

ts
Copy
Edit
app.set('etag', false);
In your download handler, also explicitly remove any caching headers before streaming:

ts
Copy
Edit
// ‚Ä¶inside router.get('/:id/download', ‚Ä¶)‚Ä¶
res.removeHeader('ETag');
res.setHeader('Cache-Control', 'no-store, no-cache, must-revalidate');
res.setHeader('Pragma', 'no-cache');
res.setHeader('Expires', '0');
That ensures every time the browser asks for /api/documents/87/download, you send 200 OK + full PDF, not a 304.

4. Putting it all together: a corrected /:id/download handler
Below is an example of how your Express route should look once you fix both ‚Äúempty fileData‚Äù and the filePath resolution. Feel free to drop this into server/routes/documents-database.ts (or merge it with your logic):

ts
Copy
Edit
import express from 'express';
import { databaseDocumentStorage } from '../services/database-document-storage.js';
import fs from 'fs';
import path from 'path';
import { requireAuth } from '../utils/auth.js';

const router = express.Router();

router.get('/:id/download', requireAuth, async (req, res) => {
  try {
    const documentId = parseInt(req.params.id, 10);
    if (isNaN(documentId)) {
      return res.status(400).json({ error: 'Invalid document ID' });
    }

    const document = await databaseDocumentStorage.getDocument(documentId);
    if (!document) {
      return res.status(404).json({ error: 'Document not found' });
    }

    // 1) If there is nonzero fileData in the DB, send it:
    if (document.fileData && document.fileData.length > 0) {
      const fileBuffer = Buffer.from(document.fileData, 'base64');
      if (fileBuffer.length > 0) {
        res.removeHeader('ETag');
        res.setHeader('Cache-Control', 'no-store, no-cache, must-revalidate');
        res.setHeader('Pragma', 'no-cache');
        res.setHeader('Expires', '0');
        res.setHeader('Content-Type', document.fileType);
        const disposition = document.fileType === 'application/pdf' ? 'inline' : 'attachment';
        res.setHeader('Content-Disposition', `${disposition}; filename="${encodeURIComponent(
          document.fileName
        )}"`);
        res.setHeader('Content-Length', fileBuffer.length.toString());
        return res.send(fileBuffer);
      }
      // If fileBuffer.length is actually 0, skip to the filesystem fallback
    }

    // 2) Otherwise, try to stream from the filesystem:
    if (document.filePath) {
      // Make sure filePath is stored as something like "storage/documents/deal-108/foo.pdf"
      const fullPath = path.resolve(document.filePath);
      if (!fs.existsSync(fullPath)) {
        console.error(`‚ùå Legacy file not found: ${fullPath}`);
        return res
          .status(410)
          .json({ error: 'Document file no longer available on disk' });
      }

      // Remove any ETag and force 200 + PDF bytes:
      res.removeHeader('ETag');
      res.setHeader('Cache-Control', 'no-store, no-cache, must-revalidate');
      res.setHeader('Pragma', 'no-cache');
      res.setHeader('Expires', '0');

      // PDF vs. other types:
      res.setHeader('Content-Type', document.fileType);
      const disposition = document.fileType === 'application/pdf' ? 'inline' : 'attachment';
      res.setHeader(
        'Content-Disposition',
        `${disposition}; filename="${encodeURIComponent(document.fileName)}"`
      );

      // Stream file off disk:
      const fileStream = fs.createReadStream(fullPath);
      fileStream.on('error', (err) => {
        console.error(`‚ùå Error streaming file ${fullPath}:`, err);
        if (!res.headersSent) {
          res.status(500).json({ error: 'Error reading file from disk' });
        }
      });
      return fileStream.pipe(res);
    }

    // 3) If neither branch worked:
    console.error(`‚ùå Document ${documentId} has no fileData and no filePath`);
    return res.status(410).json({ error: 'Document content not available' });
  } catch (error) {
    console.error('Error downloading document:', error);
    return res.status(500).json({ error: 'Internal server error during download' });
  }
});

export default router;
A few notes on this ‚Äúfixed‚Äù version:

We only treat document.fileData as a PDF if its length is > 0, otherwise we skip to filesystem.

We explicitly removeHeader('ETag') and set Cache-Control: no-store, no-cache‚Ä¶ so the browser will always do a fresh 200 OK with the full PDF stream.

We set Content-Length only when we already have a Buffer (in the DB branch). For the streaming branch, you could add res.setHeader('Content-Length', fs.statSync(fullPath).size); if you want‚Äîbut PDF.js will still render fine without it.

We choose inline vs. attachment based on fileType === 'application/pdf'. That ensures PDFs open in-browser, while other docs (e.g. .pptx/.zip/.xlsx) are downloaded.

5. Double-check your front-end usage
In client/src/components/documents/UniversalDocumentViewer.tsx (or wherever you call React‚ÄêPDF), make sure you only attempt the PDF render once you really have a nonempty URL. For example:

tsx
Copy
Edit
// Pseudocode in your React component:
const { data: docs, isLoading, isError } = useQuery(
  ['dealDocuments', dealId],
  () => fetch(`/api/documents/deal/${dealId}`).then(res => res.json())
);

if (isLoading) return <p>Loading‚Ä¶</p>;
if (isError) return <p>Error loading documents</p>;
if (!docs || docs.length === 0) return <p>No documents found</p>;

const first = docs[0];
if (!first.downloadUrl) {
  return <p>Invalid document metadata: no download URL</p>;
}

// OPTIONAL: cache-bust by appending a timestamp so the browser can‚Äôt re‚Äêuse the old zero-byte ETag
const urlWithCacheBust = `${first.downloadUrl}?cb=${Date.now()}`;

return (
  <Document
    file={urlWithCacheBust}
    onLoadError={(err) => console.error('PDF load error:', err)}
  >
    <Page pageNumber={1} />
  </Document>
);
That ?cb=${Date.now()} trick forces the browser to ignore any previous ETag. Once your server always returns 200 + nonzero content, PDF.js will happily render it.

Recap
The 304/‚Äú0 bytes‚Äù log means the download route sent back a zero-byte response (ETag "0-‚Ä¶") instead of PDF data.

Most likely cause: document.fileData existed (empty string) so you inadvertently sent back Buffer.from('', 'base64'), or you never reached the FS fallback because filePath was missing or incorrect.

Fix steps:

Change if (document.fileData) to if (document.fileData && document.fileData.length > 0) so you only send DB bytes when actual content exists.

Ensure document.filePath is stored as the full path under storage/documents/... (e.g. ‚Äústorage/documents/deal-108/Arbor Lodging Overview.pdf‚Äù), and that file really exists on disk.

In the download route, explicitly disable ETag/caching (res.removeHeader('ETag'), Cache-Control: no-store) so the browser always gets a fresh 200 with bytes.

Once those changes are in place, reload the page and watch DevTools ‚Üí Network ‚Üí ‚Äú/api/documents/87/download‚Äù:

You should see Status 200 OK (not 304),

Response Size several KB (the actual PDF),

Content-Type: application/pdf, and

No ‚ÄúInvalidPDFException‚Äù in the console.

That will fully resolve the ‚ÄúPDF file is empty‚Äù error.