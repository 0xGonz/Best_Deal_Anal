Below is a copy-and-paste prompt you can drop straight into the Replit AI ‚ÄúFix my code‚Äù box (or into a /fix task) so the agent knows exactly what‚Äôs broken, why, and the concrete steps to patch it systematically and scalably.

pgsql
Copy
Edit
# üõ†Ô∏è Replit AI Fix Brief ‚Äì DealFlowLifecycle (v28)

## 0. Goal
Stop the ‚ÄúCommitted / Part-Paid / Funded‚Äù drift in fund-allocation math, and make the pipeline rock-solid at scale (one deal or 10 000 deals).

## 1. Current Bugs to Eliminate
1. **Ad-hoc payments before a capital call**  
   ‚Ä¢ `payment.controller.ts ‚Üí recordPayment` lets payloads without `capitalCallId` create a payment directly on an allocation, bypassing `capital_calls`.  
2. **String‚Äìnumber mixing in funded math**  
   ‚Ä¢ `allocation.service.ts ‚Üí applyPaymentToAllocation` concatenates when `fundedAmount` (string) is added to a numeric `paymentAmount`, causing `"400000600000"` ‚Üí `NaN`.  
3. **Double allocations from the invested-deal webhook**  
   ‚Ä¢ `services/onDealInvested.ts` bulk-inserts an allocation even if one already exists for the same `(fund_id, deal_id)`, leading to duplicate rows and inflated roll-ups.

## 2. Architectural Fixes Required

### 2.1 Strict Money Types
* Convert every monetary column (`committed_amount`, `called_amount`, `funded_amount`, `amount` in payments & calls) to `NUMERIC(18,2)` in Postgres.  
* Update Drizzle models to map these as `bigintMode: 'number'` **or** a Decimal wrapper; no strings allowed.

### 2.2 Relational Guard-Rails
* **FK** `payments.capital_call_id REFERENCES capital_calls(id) NOT NULL ON DELETE RESTRICT`.  
* **UNIQUE(fund_id, deal_id)** on `fund_allocations`.  
* **CHECK** constraints inside `fund_allocations`:  
  ```sql
  funded_amount <= called_amount
  AND called_amount <= committed_amount
Generate called_amount & funded_amount as stored generated columns that SUM child tables, so the app never writes them manually.

2.3 State Machine Enforcement
Introduce AllocationFSM (already scaffolded) and block PAYMENT_RECEIVED events when state < partially_called.

Remove the ‚Äúad-hoc payment‚Äù branch; instead require callers to first create a zero-amount ‚Äúcatch-up‚Äù capital call if they truly need one.

2.4 Webhook Idempotency
In onDealInvested, check for an existing allocation:
If present ‚Üí update committed_amount;
If absent ‚Üí insert.

Respect the UNIQUE key above so retries don‚Äôt 500.

3. Required Deliverables
Two SQL migrations

001_money_numeric.sql ‚Äì change column types & add CHECK + UNIQUE constraints.

002_generated_totals.sql ‚Äì add generated columns & drop old mutable ones.

Code patches

payment.controller.ts ‚Äì remove ad-hoc logic, require capitalCallId.

allocation.service.ts ‚Äì ensure numeric arithmetic (Number() or Decimal), no string concat.

onDealInvested.ts ‚Äì make allocation idempotent.

allocationFSM.ts ‚Äì guard payment event.

Tests (Vitest/Jest)

New integration spec: commit ‚Üí (no call) ‚Üí payment ‚Üí expect 409 Conflict.

Happy-path spec: commit 1 M ‚Üí call 400 k ‚Üí pay 400 k ‚Üí call 600 k ‚Üí pay 600 k ‚Üí expect funded = committed = called = 1 M.

Cypress E2E script mirroring the integration test, verifying UI values.

4. Acceptance Criteria
API returns 409 if a payment is posted without an open capital call.

Dashboard always shows committed ‚â• called ‚â• funded with correct percentages.

Duplicate webhook calls don‚Äôt create extra rows.

All migrations run in < 30 s on 10k allocations (use ALTER ‚Ä¶ NOT VALID pattern).

5. Non-Goals (for now)
Multi-currency support, table partitioning, or event-outbox refactor.

Please implement all deliverables above, commit, and run the test suite until green.

pgsql
Copy
Edit

Copy everything between the triple back-ticks into the Replit agent prompt.  
It gives the agent clear context, precise files to touch, concrete SQL to write, and objective tests to pass‚Äîso the fixes come back production-ready instead of another partial patch.








